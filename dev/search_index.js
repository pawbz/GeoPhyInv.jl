var documenterSearchIndex = {"docs":
[{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"EditURL = \"<unknown>/test/fdtd/reuse_expt.jl\"","category":"page"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"This page was generated on 2021-11-29","category":"page"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"using GeoPhyInv\nusing Statistics\nusing Plots; gr();\nusing ColorSchemes\nusing Test","category":"page"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"This tutorial demonstrates how an instance of SeisForwExpt can be used iteratively to perform forward modeling using update! for various bundles of medium parameters.","category":"page"},{"location":"generated/fdtd/reuse_expt/#Medium-#1","page":"Tutorial II","title":"Medium #1","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"medium = Medium(:elastic_homo2D, 5)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Medium-#2","page":"Tutorial II","title":"Medium #2","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"medium_new = similar(medium)\nupdate!(medium_new, [:vp, :rho, :vs], rectangle = [[-500, -500], [500, 500]], perc = 5.0) # perturb velocity","category":"page"},{"location":"generated/fdtd/reuse_expt/#AGeom","page":"Tutorial II","title":"AGeom","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"ageom = AGeom(medium.mgrid, :surf, SSrcs(3), Recs(100)); # surface seismic\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Plotting-#1","page":"Tutorial II","title":"Plotting #1","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"p1=heatmap(medium, :rho, seriescolor=cgrad(:roma))\nscatter!(ageom, SSrcs())\nscatter!(ageom, Recs())\np2=heatmap(medium_new, :rho, seriescolor=cgrad(:roma))\nscatter!(ageom, SSrcs())\nscatter!(ageom, Recs())\nplot(p1, p2, size=(800,300))","category":"page"},{"location":"generated/fdtd/reuse_expt/#SrcWav","page":"Tutorial II","title":"SrcWav","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"tgrid = range(0.0, stop = 2.0, length = 2500) # generate a temporal grid\nwav = ricker(15.0, tgrid, tpeak = 0.25); # Choose a source wavelet\nsrcwav = SrcWav(tgrid, ageom, [:vz]) # initialize\nupdate!(srcwav, [:vz], wav) # distribute to all supersources","category":"page"},{"location":"generated/fdtd/reuse_expt/#SeisForwExpt","page":"Tutorial II","title":"SeisForwExpt","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"pa = SeisForwExpt(\n    FdtdElastic(),\n    medium = medium,\n    ageom = ageom,\n    srcwav = srcwav,\n    tgrid = tgrid,\n    rfields = [:vz],\n    verbose = true,\n);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Modeling-#1","page":"Tutorial II","title":"Modeling #1","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"@time update!(pa);\nd1 = copy(pa[:data][:vz])\np1=heatmap(pa[:data], :vz, 99, 99, grid=true, legend=:none, seriescolor=cgrad(:seismic));\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Change-medium-in-pa-without-memory-allocation","page":"Tutorial II","title":"Change medium in pa without memory allocation","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"update!(pa, medium_new)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Modeling-#2","page":"Tutorial II","title":"Modeling #2","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"@time update!(pa);\nd2 = copy(pa[:data][:vz])\np2=heatmap(pa[:data], :vz, 99, 99, grid=true, legend=:none, seriescolor=cgrad(:seismic));\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"Test","category":"page"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"@test d1 ≠ d2","category":"page"},{"location":"generated/fdtd/reuse_expt/#Plotting-#2","page":"Tutorial II","title":"Plotting #2","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/","page":"Tutorial II","title":"Tutorial II","text":"plot(p1,p2, size=(500, 300))","category":"page"},{"location":"generated/fdtd/doc/","page":"Description","title":"Description","text":"EditURL = \"<unknown>/test/fdtd/doc.jl\"","category":"page"},{"location":"generated/fdtd/doc/","page":"Description","title":"Description","text":"This page was generated on 2021-11-29","category":"page"},{"location":"generated/fdtd/doc/","page":"Description","title":"Description","text":"using BenchmarkTools\nusing GeoPhyInv\nusing Test","category":"page"},{"location":"generated/fdtd/doc/#Intro","page":"Description","title":"Intro","text":"","category":"section"},{"location":"generated/fdtd/doc/","page":"Description","title":"Description","text":"SeisForwExpt\nBase.getindex(::GeoPhyInv.PFdtd, ::Symbol, ::Int)","category":"page"},{"location":"generated/fdtd/doc/#GeoPhyInv.SeisForwExpt","page":"Description","title":"GeoPhyInv.SeisForwExpt","text":"pa = SeisForwExpt(attrib_mod; ageom, srcwav, medium, tgrid);\n\nMethod to create an instance of SeisForwExpt.  The output of this method can be used as an input to the in-place method update!, to actually perform a finite-difference modeling.\n\nArguments\n\nattrib_mod : attribute to choose the type of modeling. Choose from \n=FdtdAcoustic() for acoustic modeling  \n=FdtdElastic() for solving the isotropic elastic wave equation \n=FdtdAcousticBorn() for Born modeling \n\nKeyword Arguments\n\nmedium : medium parameters \ntgrid : modeling time grid, maximum time in tgrid should be greater than or equal to maximum source time, same sampling interval as in srcwav\nageom :  acquisition \nsrcwav : source wavelets  \n\nOptional Keyword Arguments\n\nsflags=2 : source related flags \n=0 inactive sources\n=1 sources with injection rate\n=2 volume injection sources\n=3 sources input after time reversal (use only during backpropagation)\nrflags=1 : receiver related flags \n=0 receivers do not record (or) inactive receivers\n=1 receivers are active only for the second propagating wavefield\nrfields=[:p] : multi-component receiver flag. Choose Vector{Symbol}\n=[:p] record pressure \n=[:vx] record horizontal component of particle velocity  \n=[:vz] record vertical component of particle velocity  \n=[:p, :vx] record both pressure and velocity \ntsnaps : store snapshots at these modeling times (defaults to half time)\n=[0.1,0.2,0.3] record at these instances of tgrid\nsnaps_field::Symbol=:tauxx : which field to record? \nzfree : z-coordinate of a stress-free horizontal layer\nverbose::Bool=false : verbose flag\n\n\n\n\n\n","category":"function"},{"location":"generated/fdtd/doc/#Base.getindex-Tuple{GeoPhyInv.PFdtd, Symbol, Int64}","page":"Description","title":"Base.getindex","text":"Indexing\n\npa is an instance of SeisForwExpt. \n\npa[:data,i] : get data for ith supersource (defaults to first), after update!\npa[:ageom] : get ageom originally input while creating pa\npa[:srcwav]: srcwav used to create pa\npa[:snaps,i] : snapshots corresponding to tsnaps and ith source, after update!\n\n\n\n\n\n","category":"method"},{"location":"generated/fdtd/doc/#Methods","page":"Description","title":"Methods","text":"","category":"section"},{"location":"generated/fdtd/doc/","page":"Description","title":"Description","text":"update!(::GeoPhyInv.PFdtd)\nupdate!(::GeoPhyInv.PFdtd, ::Medium)\nupdate!(::GeoPhyInv.PFdtd, ::SrcWav, ::Any)","category":"page"},{"location":"generated/fdtd/doc/#GeoPhyInv.update!-Tuple{GeoPhyInv.PFdtd}","page":"Description","title":"GeoPhyInv.update!","text":"update!(pa)\n\nIn-place method to perform the experiment and update pa after wave propagation. After update, see pa[:data] and pa[:snaps].\n\n\n\n\n\n","category":"method"},{"location":"generated/fdtd/doc/#GeoPhyInv.update!-Tuple{GeoPhyInv.PFdtd, Medium}","page":"Description","title":"GeoPhyInv.update!","text":"update!(pa,medium_new)\n\nUpdate pa with a new bundle of medium parameters medium_new, without additional memory allocation. This routine is used during inversion, where medium parameters are iteratively updated.  The ability to iteratively run the forward mediuming task (with no additional memory allocation) on   various subsurface mediums is necessary while implementing inversion  algorithms.\n\n\n\n\n\n","category":"method"},{"location":"generated/fdtd/doc/#GeoPhyInv.update!-Tuple{GeoPhyInv.PFdtd, Vector{GeoPhyInv.NamedD{Srcs}}, Any}","page":"Description","title":"GeoPhyInv.update!","text":"update!(pa,srcwav_new,sflags)\n\nUpdate pa with a new bundle of source wavelets srcwav_new, without additional memory allocation. Optionally, sflags can be changed. \n\n\n\n\n\n","category":"method"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"EditURL = \"<unknown>/test/fdtd/create_snaps.jl\"","category":"page"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"using GeoPhyInv\nusing Statistics\nusing Plots; gr();\nusing ColorSchemes","category":"page"},{"location":"generated/fdtd/create_snaps/#Medium","page":"Tutorial I","title":"Medium","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"medium = Medium(:acou_homo2D, 5); # load a simple homogeneous acoustic medium from the gallery\nupdate!(medium, [:vp, :rho], randn_perc = 5); # add some random noise to the medium\nprintln(medium)","category":"page"},{"location":"generated/fdtd/create_snaps/#AGeom","page":"Tutorial I","title":"AGeom","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"ageom = AGeom(medium.mgrid, :xwell, SSrcs(2)); # load a simple acquisition using `mgrid` of the medium\nprintln(ageom)","category":"page"},{"location":"generated/fdtd/create_snaps/#SrcWav","page":"Tutorial I","title":"SrcWav","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"tgrid = range(0.0, stop = 2.0, length = 2500); # generate a time grid\nwav = ricker(15.0, tgrid, tpeak = 0.25); # ricker wavelet\nsrcwav = SrcWav(tgrid, ageom, [:p]);\nupdate!(srcwav, [:p], wav);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Plotting-the-vp-model","page":"Tutorial I","title":"Plotting the vp model","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"p1=heatmap(medium, :vp, seriescolor=cgrad(:roma))\nscatter!(ageom, SSrcs())\nscatter!(ageom, Recs())\nplot(p1)","category":"page"},{"location":"generated/fdtd/create_snaps/#Acoustic","page":"Tutorial I","title":"Acoustic","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"Now we have all the required variables to create SeisForwExpt object and prepare the forward modeling. While creating, we switched the snaps_flag on, and instruct recording field at tsnaps. Once the Expt object is created, do the modeling without additional any memory allocations using update!","category":"page"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"tsnaps=tgrid[1:div(length(tgrid),20):end] # store 20 snapshots\npa = SeisForwExpt(\n    FdtdAcoustic(),\n    medium = medium,\n    ageom = ageom,\n    srcwav = srcwav,\n    snaps_field = :p,\n    tsnaps = tsnaps,\n    tgrid = tgrid,\n    rfields = [:p],\n    verbose = true,\n);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Update-pa-to-perform-modelling;-prints-time-and-allocations","page":"Tutorial I","title":"Update pa to perform modelling; prints time and allocations","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"@time update!(pa);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Extracting-snaps","page":"Tutorial I","title":"Extracting snaps","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"snaps1 = pa[:snaps, 1]; # extracting snaps of the first supersource\nsnaps2 = pa[:snaps, 2]; # second supersource\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Plotting-pressure-snapshots-after-acoustic-simulation","page":"Tutorial I","title":"Plotting pressure snapshots after acoustic simulation","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"function plot_snapshots(name)\n    clip_perc = 90\n    pmax = maximum([maximum(pa[:snaps][it]) for it = 1:length(tsnaps)])\n    pmax -= pmax * 0.01 * clip_perc\n\n    anim = @animate for it = 1:length(tsnaps)\n        plot(\n            [\n                (\n                    f = pa[:snaps, is][it];\n                    heatmap(\n                        f,\n                        aspect_ratio = 1,\n                        xlims = (1, size(f, 2)),\n                        ylims = (1, size(f, 1)),\n                        yflip = true,\n                        seriescolor = cgrad(:seismic),\n                        clims = (-pmax, pmax),\n                        legend = false,\n                    )\n                ) for is = 1:2\n            ]...,\n            title = string(\"snapshot at: \", round(tsnaps[it], digits = 5), \" s\"),\n        )\n    end\n    return gif(anim, string(name,\".gif\"), fps = 1)\nend\nplot_snapshots(\"acoustic_snaps\")","category":"page"},{"location":"generated/fdtd/create_snaps/#Elastic","page":"Tutorial I","title":"Elastic","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"Similarly, we can do the elastic wave-equation modeling","category":"page"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"medium = Medium(:elastic_homo2D, 5); # load a simple homogeneous elastic medium from the gallery\nupdate!(medium, [:vp, :vs, :rho], randn_perc = 5); # add some random noise to the medium\nprintln(medium)\nageom = AGeom(medium.mgrid, :xwell, SSrcs(2)); # load a simple acquisition using `mgrid` of the medium\nprintln(ageom)","category":"page"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"Add source term on :vz grid","category":"page"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"srcwav = SrcWav(tgrid, ageom, [:vz]);\nupdate!(srcwav, [:vz], wav);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"Perform modelling","category":"page"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"pa = SeisForwExpt(\n    FdtdElastic(),\n    medium = medium,\n    ageom = ageom,\n    srcwav = srcwav,\n    snaps_field = :vz,\n    tsnaps = tsnaps,\n    rfields = [:vz],\n    tgrid = tgrid,\n    verbose = true,\n)\n@time update!(pa);\n\nsnaps = pa[:snaps, 1];\nsnaps = pa[:snaps, 2];\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Plotting-is-vs-model","page":"Tutorial I","title":"Plotting is vs model","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"p1=heatmap(medium, :vs, seriescolor=cgrad(:roma))\nscatter!(ageom, SSrcs())\nscatter!(ageom, Recs())\nplot(p1)","category":"page"},{"location":"generated/fdtd/create_snaps/#Plotting-snapshots-after-elastic-simulation","page":"Tutorial I","title":"Plotting snapshots after elastic simulation","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/","page":"Tutorial I","title":"Tutorial I","text":"plot_snapshots(\"elastic_snaps\") # P and S waves!","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"EditURL = \"<unknown>/test/media/doc.jl\"","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"using BenchmarkTools\nusing GeoPhyInv\nusing Test\nusing Plots\ngr()","category":"page"},{"location":"generated/media/doc/#Intro","page":"Medium","title":"Intro","text":"","category":"section"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"GeoPhyInv.Medium\nMedium(::Symbol, ::Real)","category":"page"},{"location":"generated/media/doc/#GeoPhyInv.Medium","page":"Medium","title":"GeoPhyInv.Medium","text":"Mutable type for storing medium parameters.\n\nmod=Medium(mgrid, names=[:vp,:vs,:rho]) # initiate elastic medium\nmod=Medium(mgrid, names=[:vp,:rho]) # initiate acoustic medium\n\nThis initializes a subsurface model with :vp, :rho and :vs parameters. Print the names of the medium parameters stored in mod.\n\nnames(mod)\n\nIndexing\n\nmod.mgrid : returns the spatial-grid bundle\nmod[:vp] : P-wave velocity\nmod[:vs] : S-wave velocity\nmod[:rho] : mass density\nmod[:Zp] : P-wave impedance \nmod[:K] : bulk modulus (unrelaxed when considering attenuation) \nmod[:M] : P-wave modulus\nmod[:mu] : shear modulus\nmod[:Q] : quality factor (relaxation times are optimized to be constant over all frequencies; see Robertsson, et. al, 1994)\nmod.ref : reference medium parameters \nmod.bounds : bounds of medium parameters\n\n\n\n\n\n","category":"type"},{"location":"generated/media/doc/#GeoPhyInv.Medium-Tuple{Symbol, Real}","page":"Medium","title":"GeoPhyInv.Medium","text":"mod=Medium(attrib)\n\nAs of now, only seismic models are predefined in this package. Choose attrib::Symbol\n\n=:acou_homo2D : a test homogeneous acoustic model\n=:acou_homo2 : a test homogeneous acoustic model, but with coarser spatial sampling (faster testing)\n=:marmousi2 : marmousi2 model with lower resolution; useful for surface seismic experiments\n=:marmousi2_small : a smaller section of marmousi2 \n=:pizza : :acou_homo2 with some perturbations \n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#Examples","page":"Medium","title":"Examples","text":"","category":"section"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Load a predefined model.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"medium = Medium(:elastic_homo3D);\nnothing #hide","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Get the medium parameters that are stored.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"names(medium)","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Look at the reference values.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"medium.ref","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Inspect the bounds.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"medium.bounds","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Plotting is easy","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"p1=heatmap(medium, :vp)\nplot(p1,size=(800,400))","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"To construct an instance of 2-D Medium, we need ranges for z and x.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"mgrid = [range(0.0, stop = 10.0, step = 0.1), range(0.0, stop = 30.0, step = 0.2)];\nnothing #hide","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"For 3-D, it is z, y and x.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"mgrid = fill(range(-10, stop = 10.0, step = 0.1), 3)","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Allocate basic medium parameters on the grid.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"medium = Medium(mgrid, [:vp, :rho, :vs]);\nnothing #hide","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Bounds for these parameters should be input for modeling or inversion. Use update!","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"vpb = [2100.0, 2200.0];\nvsb = [1500, 1700];\nrhob = [2100.0, 2300.0];\nupdate!(medium, [:vp, :vs, :rho], [vpb, vsb, rhob]);\nnothing #hide","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Just fill medium with average (reference) values.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"fill!(medium);\nnothing #hide","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Once the basic medium parameters are input, we can access some other derived parameters.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"medium[:Zp];\nnothing #hide","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"Otherwise, we can manually update parameters of medium.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"medium[:vp] .= 3000.0;\nmedium[:vs] .= 2000.0;\n\nprintln(medium)","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"A model can be also be updated by adding random noise.","category":"page"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"update!(medium, [:vp, :rho], randn_perc = 1.0);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#Methods","page":"Medium","title":"Methods","text":"","category":"section"},{"location":"generated/media/doc/","page":"Medium","title":"Medium","text":"\n````@example doc\nmd # Base.getindex(::Medium, ::Symbol)\n````\n\nGeoPhyInv.update!(::GeoPhyInv.Medium, ::Vector{Symbol},)\nBase.copyto!(x::AbstractArray, medium::Medium, fields::Vector{Symbol})\nBase.vec(medium::Medium, ::Symbol)","category":"page"},{"location":"contributing/#Coding-Conventions","page":"-","title":"Coding Conventions","text":"","category":"section"},{"location":"contributing/","page":"-","title":"-","text":"This software is organised into various modules. Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  distance = velocity * time is prefered over using  a = b * c in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation (Image: guide)","category":"page"},{"location":"contributing/","page":"-","title":"-","text":"The methods ending with ! ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"EditURL = \"<unknown>/test/srcwav/doc.jl\"","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"This page was generated on 2021-11-29","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"using GeoPhyInv\nusing Random\nusing LinearAlgebra","category":"page"},{"location":"generated/srcwav/doc/#Intro","page":"SrcWav","title":"Intro","text":"","category":"section"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"SrcWav","category":"page"},{"location":"generated/srcwav/doc/#GeoPhyInv.SrcWav","page":"SrcWav","title":"GeoPhyInv.SrcWav","text":"A mutable type that bundles multi-component source wavelets. \n\nsrcwav=SrcWav(tgrid, ageom, [:p, :vx])\n\n\nHere, we initialized wavelets, for :p and :vx fields, in time domain for sources and supersources in ageom.\n\nIndexing\n\nsrcwav[i] : wavelets for ith supersource of all fields\nsrcwav[i][:p] : extract field :p \nsrcwav[i][:ns] : number of sources (same as in ageom)\nsrcwav.grid : returns tgrid \n\nAs mutable objects in Julia are like containers that might hold different values over time, srcwav can be modified.\n\n\n\n\n\n","category":"type"},{"location":"generated/srcwav/doc/#Examples","page":"SrcWav","title":"Examples","text":"","category":"section"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Define an acquisition geometry.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Need a time grid.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"tgrid=range(0, stop=1.0, step=0.1);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Lets initialize records for :p field.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"srcwav=SrcWav(tgrid, ageom, [:p]);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Fill the :P field of 3rd supersource with random numbers.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"randn!(srcwav[3][:p]);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Often we want to populate the same source wavelet to all the supersources and sources.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"x=randn(length(tgrid));\nupdate!(srcwav, [:p,], x);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Populate two different wavelets for first and second supersources.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"x1=randn(length(tgrid));\nx2=randn(length(tgrid));\nupdate!(srcwav[1], [:p,], x1);\nupdate!(srcwav[2], [:p,], x2);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Scale srcwav by a scalar overwriting it in-place.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"rmul!(srcwav, 2.0);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#Methods","page":"SrcWav","title":"Methods","text":"","category":"section"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"Most of the methods listed below are also applicable to individual elements of srcwav.","category":"page"},{"location":"generated/srcwav/doc/","page":"SrcWav","title":"SrcWav","text":"update!(GeoPhyInv.VNamedD, ::Vector{Symbol}, ::AbstractArray)\nBase.reverse!(::GeoPhyInv.VNamedD)\nBase.iszero(::GeoPhyInv.VNamedD)\nBase.isequal(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nGeoPhyInv.issimilar(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nBase.vec(::GeoPhyInv.VNamedD)\nRandom.randn!(::GeoPhyInv.VNamedD)\nBase.fill!(::GeoPhyInv.VNamedD, ::Float64)\nLinearAlgebra.dot(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nLinearAlgebra.rmul!(::GeoPhyInv.VNamedD, ::Number)\nBase.copyto!(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nBase.copyto!(::AbstractVector{Float64}, ::GeoPhyInv.VNamedD)\nBase.copyto!(::GeoPhyInv.VNamedD, ::AbstractVector{Float64})","category":"page"},{"location":"generated/srcwav/doc/#Base.reverse!-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"Base.reverse!","text":"reverse!(srcwav)\n\nPerform in-place time-reversal operation for each wavelet in srcwav.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.iszero-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"Base.iszero","text":"iszero(srcwav)\n\nReturns bool if srcwav has all zeros.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.isequal-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}, Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"Base.isequal","text":"isequal(srcwav1, srcwav2)\n\nAssert if srcwav1 and srcwav2 are equal.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#GeoPhyInv.issimilar-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}, Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"GeoPhyInv.issimilar","text":"issimilar(srcwav1, srcwav2)\n\nAssert if srcwav1 and srcwav2 have same dimensions and fields.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.vec-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"Base.vec","text":"v=vec(srcwav)\nReshape `srcwav` as a one-dimensional column vector.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Random.randn!-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"Random.randn!","text":"Fill srcwav with Random values.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.fill!-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}, Float64}","page":"SrcWav","title":"Base.fill!","text":"fill!(srcwav, b)\n\nIn-place method to fill srcwav with scalar b.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#LinearAlgebra.dot-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}, Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"LinearAlgebra.dot","text":"dot(srcwav1, srcwav2)\n\nReturns dot product. The sizes must match.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#LinearAlgebra.rmul!-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}, Number}","page":"SrcWav","title":"LinearAlgebra.rmul!","text":"rmul!(srcwav, b)\n\nScale srcwav for all supersources by a scalar b overwriting in-place.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}, Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"Base.copyto!","text":"copyto!(srcwav1, srcwav2)\n\nCopy srcwav2 to srcwav1, which has same size.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{AbstractVector{Float64}, Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}}","page":"SrcWav","title":"Base.copyto!","text":"copyto!(v, srcwav)\n\nSame as vec(srcwav), but in-place operation.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{Union{Vector{GeoPhyInv.NamedD{Recs}}, Vector{GeoPhyInv.NamedD{Srcs}}}, AbstractVector{Float64}}","page":"SrcWav","title":"Base.copyto!","text":"v=vec(srcwav) \nrandn!(v)\ncopyto!(srcwav, v)\n\nCopy v to srcwav. The sizes of the two objects much match. No memory allocations.\n\n\n\n\n\n","category":"method"},{"location":"#The-Expt-Types","page":"Home","title":"The Expt Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The methods in this package numerically solve some differential equations commonly faced in geophysical inverse problems. The functionality of this package revolves around the mutable Expt types. Julia's multiple dispatch is used to overload Base methods whenever possible.  Which means, if one is familiar with the Base methods of Julia, then (almost) no additional syntax is required  to use this package. Easy!","category":"page"},{"location":"","page":"Home","title":"Home","text":"While performing a given experiment, firstly, most of the memory necessary is allocated while creating the Expt variables. Then these variables are input to in-place functions  (e.g., update!)  which as per Julia convention ends with an exclamation mark, to actually perform the experiment task. For example, the current Expt types within the realm of this package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SeisForwExpt is the seismic (both acoustic and elastic) forward modeling experiment;\nSeisInvExpt is the type for seismic inversion experiment, including migration;\nPoissonExpt is type for the solving the Poisson experiment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of the commonly used (and exported) mutable types to create the Expt variables are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Medium for bundling medium parameters together;\nAGeom stores acquisition geometry related parameters;\nSrcWav allocates source signals input to an experiment;\nRecords allocated the output records that are fitted during inversion.","category":"page"},{"location":"#Loading-the-package","page":"Home","title":"Loading the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is important to configure GeoPhyInv with a macro @init_parallel_stencil before anything else. If you need to change this configuration, julia kernel must be restarted.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoPhyInv # load package (after installation)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeoPhyInv.@init_parallel_stencil","category":"page"},{"location":"#GeoPhyInv.@init_parallel_stencil","page":"Home","title":"GeoPhyInv.@init_parallel_stencil","text":"Initialize the package with ParallelStencil, giving access to its main functionality. \n\n@init_parallel_stencil(ndims, use_gpu, datatype, order)\n\nArguments\n\nndims::Int: the number of dimensions used for the stencil computations 2D or 3D \nuse_gpu::Bool : use GPU for stencil computations or not\ndatatype: the type of numbers used by field arrays (e.g. Float32 or Float64)\norder::Int ∈ [2,4,6,8] : order of the finite-difference stencil \n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"After this, to get started with modelling or inversion, as an example, simply load a seismic inversion experiment already defined in our package gallery into REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pa=SeisInvExpt(FdtdAcoustic(), LS(), :pizza); # \"pizza\" is the name of the experiment","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, simply use update! to perform least-squares inversion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"update!(pa, solver=:ipopt)","category":"page"},{"location":"#Fields","page":"Home","title":"Fields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a given attrib_mod and ndims, you can always print a list of scalar fields that are active.  The idea is that these symbols will be used ","category":"page"},{"location":"","page":"Home","title":"Home","text":"to generate mutable types like SrcWav or Records;\nas input to keywords like rfields or snaps_field.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, lets look at the list of all the scalar fields defined in this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fields()","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can always filter this list depending on the type of the SeisForwExpt i.e., attrib_mod and the number of dimensions. For example, lets check out the fields for 3-D acoustic simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fields(FdtdAcoustic(), ndims=3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, for 2-D elastic simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fields(FdtdElastic(), ndims=2)","category":"page"},{"location":"#Grids","page":"Home","title":"Grids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is necessary to input the evenly-spaced spatial and temporal grids while creating the Expt variables. These grids can be simply created using Base.range in Julia, as shown below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"zgrid=range(0,stop=1000.0,length=201) # create vertical grid from 0 to 1000 m\nxgrid=range(0,stop=1000.0,length=201) # similarly, create horizontal grid","category":"page"},{"location":"","page":"Home","title":"Home","text":"While constructing spatial-grid bundle, watch out for order.","category":"page"},{"location":"","page":"Home","title":"Home","text":"mgrid=[zgrid, xgrid] # 2D\nmgrid=[zgrid, ygrid, xgrid] # 3D\n@info string(\"spatial sampling intervals (dz, dy, dx)=\", step.(mgrid))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, a temporal grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tgrid=range(0,stop=1.0,step=0.001) # a temporal grid from 0 to 1.0 s","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"EditURL = \"<unknown>/test/ageom/doc.jl\"","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"This page was generated on 2021-11-29","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"using GeoPhyInv\nusing Test","category":"page"},{"location":"generated/ageom/doc/#Intro","page":"AGeom","title":"Intro","text":"","category":"section"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"AGeom","category":"page"},{"location":"generated/ageom/doc/#GeoPhyInv.AGeom","page":"AGeom","title":"GeoPhyInv.AGeom","text":"AGeom=Vector{AGeomss,1}\n\nAn acquisition geometry, bundled into the mutable AGeom type, has to be specified in order to create any Expt variable. Acquisition has supersources, sources and receivers. For AGeom is a mutable type to define source-receiver geometry.  Each supersource has ns sources that are injected (or active) simultaneously, and  a set of nr receivers to  record.  AGeomss is a subtype for each supersource, therefore: This package provides tools to easily create commonly-used AGeom instances,  after deciding on a spatial grid mgrid for the experiment.\n\nIndexing and Fields\n\nLet ageom be an instance of this type, then fields  can be accessed using:\n\nageom[i] : acquisition for ith supersource\nageom[i].s[p] : position coordinates of sources where p ∈ [:z, :x, :y]\nageom[i].r[p] : position coordinates of receivers\nageom[i].ns : number of sources \nageom[i].nr : number of receivers\n\nageom=AGeom(mgrid, attrib, SSrcs(10), Recs(20))\n\nReturn pre-defined acquisition geometries (in this case with 10 supersources and 20 receivers), based on attrib, on an input mesh mgrid. The sources and receivers positions are same for all supersources, and are not placed on the edges of the mesh. Choose attrib::Symbol\n\n=:xwell cross-well acquisition;\n=:surf surface acquisition;\n=:vsp vertical seismic profiling;\n=:rvsp  reverse vertical seismic profiling;\n=:downhole downhole sources and receivers.\n\nTODO: For 3D, just mean(ygrid) is used, need to work on more exotic gallery of 3D acquisitions.\n\n\n\n\n\n","category":"type"},{"location":"generated/ageom/doc/#Examples","page":"AGeom","title":"Examples","text":"","category":"section"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"Lets create a 2-D mgrid for the experiment.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"mgrid2 = [range(0.0, stop = 10.0, step = 0.1), range(0.0, stop = 30.0, step = 0.2)];\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"Then initialize an acquisition on mgrid, where the positions will be randomly chosen.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"ageom2 = AGeom(mgrid2, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"Similarly, we can do it for 3D too.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"mgrid3 = fill(range(-10, stop=10, step=0.01),3);\nageom3 = AGeom(mgrid3, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"You can check the number of dimensions.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"ndims(ageom2), ndims(ageom3) == 2, 3","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"For 2D, we can also initialize with one of the predefined acquisitions.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"ageom2 = AGeom(mgrid2, :xwell, SSrcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"By default, the sources and receivers are randomly placed on the grid. If unsure, test it.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"@test (ageom2 ∈ mgrid2)\n@test (ageom3 ∈ mgrid3)","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"The source and receiver positions can be updated as desired.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"update!(ageom2[1], Srcs(), [0, 1], [10, 20]);\nupdate!(ageom2[1], Recs(), [0, 0], [10, 20]);\nupdate!(ageom2, SSrcs(), [0, 1], [10, 20]);\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"It is easy to combine supersources. Now ageom2 has 20 supersources.","category":"page"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"ageom2_new = vcat(ageom2, ageom2);\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#Methods","page":"AGeom","title":"Methods","text":"","category":"section"},{"location":"generated/ageom/doc/","page":"AGeom","title":"AGeom","text":"update!(::AGeomss, ::Srcs)\nupdate!(::AGeomss, ::Recs)\nupdate!(::AGeom, ::SSrcs)\nupdate!(::AGeom, ::Recs)\nBase.in(::AGeom, ::AbstractVector{StepRangeLen})\nBase.isequal(::AGeom, ::AGeom)\nSparseArrays.SparseMatrixCSC(::AGeomss,::AbstractVector{StepRangeLen})","category":"page"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{AGeomss, Srcs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom[1], Srcs(10), p1, p2)\n\nUpdate source geometry for the first supersource, with 10 sources placed regularly between p1=[z1,x1] and p2=[z2,x2]\n\nupdate!(ageom[2], Srcs(10), p0, rad, angles)\n\nUpdate source geometry for the second supersource, with 10 sources placed equidistant from p0=[z0,x0] given radius rad and angles angles=[0,2pi].\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{AGeomss, Recs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom[1], Recs(10), args...)\n\nSimilar to updating source positions, but for receivers.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{Vector{AGeomss}, SSrcs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom, SSrcs(), p1, p2)\nupdate!(ageom, SSrcs(), p0, rad, angles)\n\nUpdate all source positions in each supersources. \n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{Vector{AGeomss}, Recs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom, Recs(), p1, p2)\nupdate!(ageom, Recs(), p0, rad, angles)\n\nUpdate receiver positions for all supersources.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#Base.in-Tuple{Vector{AGeomss}, AbstractVector{StepRangeLen}}","page":"AGeom","title":"Base.in","text":"ageom ∈ mgrid\nin(ageom, mgrid)\n\nAssert if all the sources and receivers in AGeom are within bounds of mgrid.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#Base.isequal-Tuple{Vector{AGeomss}, Vector{AGeomss}}","page":"AGeom","title":"Base.isequal","text":"isequal(ageom1, ageom2)\n\nAssert if ageom1 equals ageom2.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#SparseArrays.SparseMatrixCSC-Tuple{AGeomss, AbstractVector{StepRangeLen}}","page":"AGeom","title":"SparseArrays.SparseMatrixCSC","text":"A=SparseArrays.SparseMatrixCSC(ageom[1],mgrid)\nD=A*P\n\nReturn a sparse matrix that restricts the field P on mgrid to receiver positions, to give D.\n\n\n\n\n\n","category":"method"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"EditURL = \"<unknown>/test/data/doc.jl\"","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"This page was generated on 2021-11-29","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"using GeoPhyInv\nusing Test\nusing Random","category":"page"},{"location":"generated/data/doc/#Intro","page":"Records","title":"Intro","text":"","category":"section"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"Records","category":"page"},{"location":"generated/data/doc/#GeoPhyInv.Records","page":"Records","title":"GeoPhyInv.Records","text":"A mutable type that bundles multi-component records at receiver array.\n\nrecords=Records(tgrid, ageom, [:p, :vx])\n\n\nHere, we initialized records, of :p and :vx fields, in time domain for receivers and supersources in ageom.\n\nIndexing\n\nrecords[i] : the records due to ith supersource of all fields\nrecords[i][:p] : extract field :p \nrecords[i][:nr] : number of receivers (same as in ageom)\nrecords.grid : returns tgrid \n\nAs mutable objects in Julia are like containers that might hold different values over time, records can be modified.\n\n\n\n\n\n","category":"type"},{"location":"generated/data/doc/#Examples","page":"Records","title":"Examples","text":"","category":"section"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"Define an acquisition geometry.","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"Need a time grid.","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"tgrid=range(0, stop=1.0, step=0.1);\nnothing #hide","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"Lets initialize records for :P and :vz fields.","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"data=Records(tgrid, ageom, [:p,:vz]);\nnothing #hide","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"Fill the :P field of 3rd supersource with random numbers.","category":"page"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"Random.randn!(data[3][:p]);\nnothing #hide","category":"page"},{"location":"generated/data/doc/#Methods","page":"Records","title":"Methods","text":"","category":"section"},{"location":"generated/data/doc/","page":"Records","title":"Records","text":"Methods listed for SrcWav can used on instances of Records too.","category":"page"}]
}
